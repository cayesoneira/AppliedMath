### Comandos de interés:

- `errorbar(abscisa,ordenada,vector de errores);`
- `./` divide componente a componente: es el efecto del punto delante del signo de operación
- `plot(h(1,end-1),p)` si p mide una posición más que h; cogemos hasta la penúltima componente de h
- `axis` va con cuatro valores: abscisa mínima, abscisa máxima, ordenada mínima, ordenada máxima.
- la derivada simbólica en matlab no necesita especificar la variable si solo hay una variable; de hecho, matlab da prioridad a la x.
- `contour` hace las curvas de nivel; `contourf` las *rellena* (fill)
- `repmat`: *repite un vector para hacer una matriz*
- `trapz` es aplicar la regla del trapecio dando un vector de abscisas y otro de ordenadas.
- `orden(F, bc, sol, @normaInf, 'Orden de convergencia en norma L^\infty', 1.9, 2.1)`: esto es un ejemplo de mi *function* que calcula el orden. Lo llamativo es que uno de los argumentos de mi *function* es otra *function*, lo que hay que hacer es poner un `@` para convertirla en una **función anónima**. Si el argumento es directamente una función anónima (por ejemplo declarada tipo `f=@(x) x^2`) entonces no hace falta poner el `@` cuando se usa como argumento.
- Formatos de número en `disp`: `disp([' Dx = ' num2str(dx,'%4.3f')])` dice con el `%4.3f` que quiere un *float* con ciertos decimales, etc.
- Muy interesante la `struct`: una especie de tabla donde pueden introducirse funciones, etc. a las que luego te refieres por etiquetas. Muy potente y útil: se puede usar como argumento de una `function`.
- `nn = [nn norm(nl.yk)]`: básicamente esto es *alargar un vector*.
- Empezamos declarando la función anónima `sol = @(x) exp(x) + cos(x)`, ahora avisamos que *x* es simbólica: `syms x`, acto seguido, sustituyendo en la función anónima la variable simbólica lo que tenemos es precisamente una función simbólica que se puede derivar simbólicamente: `diff(sol(x),x)`, ahora convertimos esta función simbólica en una función anónima que denotamos como *dsol*: `dsol = matlabFunction(diff(sol(x),x))`. Ya podemos crear un vector de ordenadas simplemente haciendo `ye = sol(xh)`.
- Cuando ponemos un `disp` o un `error` lo que ponemos en principio es `error('El algoritmo no converge en iteraciones.')` o quizá `error(nl.maxit)`, es decir, o texto o un número directamente. Si queremos escribir un mensaje que incluya el número y el texto, tenemos que poner **un array de strings**: `error(['El algoritmo no converge en ' num2str(nl.maxit) ' iteraciones.'])`, precisamente con el `[]`. En `title` sí hay que separarlo por comas, en `error` y `disp` parece que no.
- Click en los números de línea en Matlab posibilita crear un punto de stop de correr el código que permite ir ejecutando poco a poco desde ahí e ir viendo qué se ha ido declarando.
- `[a, b, c, d] = deal(1, 2, 3, 4)` sirve para asignar en una sola línea lo que sería `a = 1, b = 2, c = 3, d= 4`.
- `ode45` resuelve un sistema de ecuaciones diferenciales por métodos de Runge Kutta de orden 4 y 5.
- Quizá la forma más cómoda de poner varias figuras juntas: `subplot`.
- `sparse`hace matrices de ceros.
-  `mesher` es una función para crear la malla.
---
### Ideas/comentarios:

- Condiciones de contorno Dirichlet (fijar la solución), Neumann (fijar las derivadas de la solución), Robin (combinación lineal de los valores de una función y los valores de su derivada sobre la frontera del dominio), mixtas[?] (combinación cualquiera)
- Por ahora la asignatura parece ir poco a poco, explicando matlab desde la base (las clases son programación guiada con la explicación de los comandos).
- para un pc de 64 bits el eps de la maq es `2.22e-16`
- Matlab se lleva mal con la memoria dinámica: es mejor que los vectores se declaren directamente con su dimensión. Lo otro podría causar que la memoria deba estar realojándose, lo cual ralentiza el proceso.
- la matemática computacional tiene dos límites: el matemático (h's pequeños deben usarse) y el computacional (h's más grandes que el eps de la máquina); hay un intervalo para el h con el que debemos trabajar.
- Concepto de *test académico*: eufemismo elegante para decir *ejercicio*
- Método de elementos finitos >> Método de diferencias finitas >> Métodos para problemas de valor inicial >> Runge Kutta's
- Tener condiciones Dirichlet se denomina también *bloquear*; cond dirichlet en cierto extremo se dice *bloquear* dicho extremo.
- Con condiciones Dirichlet los errores crecen cuando nos acercamos al centro del intervalo: en los extremos ya estamos dando la solución. No pasa lo mismo con condiciones mixtas, que pueden ser fuente de error de por sí.
- Evolutivo = No estacionario.
- El numérico aporta intuición sobre qué temas teóricos pueden tener solución o no (temas de existencia y unicidad, etc.) y si perder el tiempo en ellos.
- La iteración funcional se puede aplicar también a EDs considerando un operador que incluya las acciones de *derivar*, entre otras operaciones. El objetivo de la iteración funcional siempre ha sido escribir la solución como un punto fijo de una aplicación. El tema 4 hace un interesante ejercicio sobre estas ideas.
- En el núcleo del algoritmo originario de Deep Learning se encuentra un algoritmo de Newton, esto es, una aproximación de un problema por otro problema lineal.
- ¿Por qué ponemos un *or* (||) en lugar de un *and* (&&) en las condiciones de Tolerancia del Residuo y Tolerancia en la Abscisa? Es decir,`if ydif < nl.tol || Fres < nl.tol`. Pues porque si la función es muy muy muy *vaso* entonces converge rápido en la ordenada pero en la abscisa quizá cuando converja el residuo en la ordenada ya sea del orden del épsilon de la máquina.
- El método de Newton para ecs. dif., por contra a iteración funcional, converge muy rápidamente, especialmente con un iterante inicial adecuado. Iteración funcional, sin embargo, perfectamente puede dar lugar a falsas convergencias: converge *a paso de tortuga*.
- **benchmark**: comparativa de rendimiento; básicamente correr un problema resuelto y tabulado con nuestro programa para ver si *tira como debe*.
- Tiene tela que la primera vez en la vida que derivo un operador que incluye operaciones de derivadas (G(y)=y''-u(x)-v(x)y^m-w(x)y') sea en esta asignatura. Bastante peculiar e incomprensible el proceso, de hecho.
- Hay problemas donde la información que se da en la ecuación diferencial es la condición final, no siempre debe ser necesariamente la condición inicial. El hecho es dar tanta información en la variable i-ésima como grados tiene la derivada de dicha variable (i.e. y'' => 2 cond. de contorno).
- La primera vez que tratamos de resolver un problema evolutivo usamos el *método de Euler implícito* para la variable t y *diferencias finitas* para la variable x.
- Para las derivadas primera y segunda hay distintas aproximaciones: podemos hacerlo en i+1 e i, en i-1 e i (de primer orden, lo primero que se ve) o en i-1, i e i+1 (esto son aproximaciones de segundo orden: i-1 e i+1 para la derivada).
- Implementar diferencias finitas hace posible escribir el problema como una ecuación en diferencias (i.e. una ecuación que involucra y_i-1, y_i, y_i+1,, etc.) cuya resolución viene de resolver un sistema matricial (pues al final tenemos un conjunto de ecuaciones lineales).
- Muy interesante este
- Testear código vale dinero. Por eso hay que usarlo lo más posible antes de cambiarlo.
- Ecuaciones diferenciales rígidas (*stiff*) y no rígidas (*non-stiff*): un caso, según Fran, en el que física y métodos numéricos se dan la mano de una forma especial: los *non-stiff* son aquellos que requerirían un paso atento de una iteración a otra por tratarse de modelos de variación muy súbita, y así la física que describen. Los *non-stiff* son mucho más caros por tener que ser más atentos  (por ejemplo con paso variable): los *stiff*, sin embargo, son suficientemente estables y sencillos como para aplicar el mismo método a toda la resolución del problema.
- Aún no alcanzo a comprender por qué, dado que soy neófito en Elementos Finitos, pero al parecer ser puede hacer con polígonos de tantos lados como se quiera.
- El método de diferencias finitas se basa únicamente en plantear un sistema de ecuaciones sobre el vector solución con la información de cómo derivar numéricamente para que converja a la derivada.
- Las condiciones de contorno Robin para el caso de la ecuación del calor tienen perfecto sentido en un contexto de difusión del calor en el borde con dependencia de la temperatura ambiente. Es decir, que, interpretada, esta condición tiene sentido física satisfactorio.
- Dice Fran que FEM en varias dimensiones es el mejor recurso en la actualidad para resolver EDPs, de ahí su interés para nuestro estudio.
- COMSOL nació como PDETool de Matlab, dice Fran.
- La gran ventaja de los FEM frente a los método de diferencias finitas es que en 2D y 3D necesitamos mallados tremendamente regulares, pues la ecuación fundamental que permite crear la matriz proviene de una forma de aproximar las derivadas y juega un papel clave el tamaño de los intervalos, etc. En FEM, sin embargo, las regiones son de tamaño arbitrario: esto permite ahorrar una de tiempo de cálculo enorme al centrarnos en las regiones que nos interesan.
- Tratamos de cambiar la ecuación diferencial original por una ecuación integral, lo que se denomina formulación débil, para estar en las hipótesis de Lax-Milgram: un teorema que involucra, de Hilbert, condiciones de existencia de solución para dicho problema. Una especie de *podemos encontrar un elemento ortogonal*. Y esto solo es posible en el lenguaje de integrales, etc., por representar productos escalares o normas.
- The Finite Element Method: Its Basis and Fundamentals by Olek C Zienkiewicz (Author), Robert L Taylor (Author) y J.Z. Zhu (Author). Según Fran, la biblia de los Elementos Finitos.
- **Formas de escribir la condición Dirichlet en FEM.** *Bloqueo por sustitución*: cambia muchísimos elementos de la matriz, pero mantiene la estructura. *Bloqueo por pivote*: cambia el mínimo número de elementos de la matriz, pero puede estropear el número de condicionamiento. *Bloqueo por condensación*: no solo modifica los valores de la matriz, sino también la estructura.
- A partir de FEM cuadrático el número de nodos ya es más grande estrictamente que el número de vértices de la malla.
- Hay dos formas en FEM de *refinar* la resolución: en primer lugar, aumentar el grado; en segundo lugar, estrechar el tamaño del elemento finito, i.e. hacer más fina la malla. Se denominan *métodos hk* a los que van cambiando estos valores de forma óptima.
- Estudiar la matriz del FEM puede ser útil antes de resolver: puede ser útil calcular los autovalores más grandes y quitarle a dicha matriz los cachos que no involucren dichos autovalores. Son la familia de lo *métodos de orden reducido*, muy relacionado también con los métodos de *Singular Value Decomposition (SVD)*.
- 
