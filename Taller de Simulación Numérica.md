### Comandos de interés:

- `errorbar(abscisa,ordenada,vector de errores);`
- `./` divide componente a componente: es el efecto del punto delante del signo de operación
- `plot(h(1,end-1),p)` si p mide una posición más que h; cogemos hasta la penúltima componente de h
- `axis` va con cuatro valores: abscisa mínima, abscisa máxima, ordenada mínima, ordenada máxima.
- la derivada simbólica en matlab no necesita especificar la variable si solo hay una variable; de hecho, matlab da prioridad a la x.
- `contour` hace las curvas de nivel; `contourf` las *rellena* (fill)
- `repmat`: *repite un vector para hacer una matriz*
- `trapz` es aplicar la regla del trapecio dando un vector de abscisas y otro de ordenadas.
- `orden(F, bc, sol, @normaInf, 'Orden de convergencia en norma L^\infty', 1.9, 2.1)`: esto es un ejemplo de mi *function* que calcula el orden. Lo llamativo es que uno de los argumentos de mi *function* es otra *function*, lo que hay que hacer es poner un `@` para convertirla en una **función anónima**. Si el argumento es directamente una función anónima (por ejemplo declarada tipo `f=@(x) x^2`) entonces no hace falta poner el `@` cuando se usa como argumento.
- Formatos de número en `disp`: `disp([' Dx = ' num2str(dx,'%4.3f')])` dice con el `%4.3f` que quiere un *float* con ciertos decimales, etc.
- Muy interesante la `struct`: una especie de tabla donde pueden introducirse funciones, etc. a las que luego te refieres por etiquetas. Muy potente y útil: se puede usar como argumento de una `function`.
- `nn = [nn norm(nl.yk)]`: básicamente esto es *alargar un vector*.
- Empezamos declarando la función anónima `sol = @(x) exp(x) + cos(x)`, ahora avisamos que *x* es simbólica: `syms x`, acto seguido, sustituyendo en la función anónima la variable simbólica lo que tenemos es precisamente una función simbólica que se puede derivar simbólicamente: `diff(sol(x),x)`, ahora convertimos esta función simbólica en una función anónima que denotamos como *dsol*: `dsol = matlabFunction(diff(sol(x),x))`. Ya podemos crear un vector de ordenadas simplemente haciendo `ye = sol(xh)`.
- Cuando ponemos un `disp` o un `error` lo que ponemos en principio es `error('El algoritmo no converge en iteraciones.')` o quizá `error(nl.maxit)`, es decir, o texto o un número directamente. Si queremos escribir un mensaje que incluya el número y el texto, tenemos que poner **un array de strings**: `error(['El algoritmo no converge en ' num2str(nl.maxit) ' iteraciones.'])`, precisamente con el `[]`. En `title` sí hay que separarlo por comas, en `error` y `disp` parece que no.
- Click en los números de línea en Matlab posibilita crear un punto de stop de correr el código que permite ir ejecutando poco a poco desde ahí e ir viendo qué se ha ido declarando.
- 
---
### Ideas/comentarios:

- Condiciones de contorno Dirichlet (fijar la solución), Neumann (fijar las derivadas de la solución), Robin (combinación lineal de los valores de una función y los valores de su derivada sobre la frontera del dominio), mixtas[?] (combinación cualquiera)
- Por ahora la asignatura parece ir poco a poco, explicando matlab desde la base (las clases son programación guiada con la explicación de los comandos).
- para un pc de 64 bits el eps de la maq es `2.22e-16`
- Matlab se lleva mal con la memoria dinámica: es mejor que los vectores se declaren directamente con su dimensión. Lo otro podría causar que la memoria deba estar realojándose, lo cual ralentiza el proceso.
- la matemática computacional tiene dos límites: el matemático (h's pequeños deben usarse) y el computacional (h's más grandes que el eps de la máquina); hay un intervalo para el h con el que debemos trabajar.
- Concepto de *test académico*: eufemismo elegante para decir *ejercicio*
- Método de elementos finitos >> Método de diferencias finitas >> Métodos para problemas de valor inicial >> Runge Kutta's
- Tener condiciones Dirichlet se denomina también *bloquear*; cond dirichlet en cierto extremo se dice *bloquear* dicho extremo.
- Con condiciones Dirichlet los errores crecen cuando nos acercamos al centro del intervalo: en los extremos ya estamos dando la solución. No pasa lo mismo con condiciones mixtas, que pueden ser fuente de error de por sí.
- Evolutivo = No estacionario.
- El numérico aporta intuición sobre qué temas teóricos pueden tener solución o no (temas de existencia y unicidad, etc.) y si perder el tiempo en ellos.
- La iteración funcional se puede aplicar también a EDs considerando un operador que incluya las acciones de *derivar*, entre otras operaciones. El objetivo de la iteración funcional siempre ha sido escribir la solución como un punto fijo de una aplicación. El tema 4 hace un interesante ejercicio sobre estas ideas.
- En el núcleo del algoritmo originario de Deep Learning se encuentra un algoritmo de Newton, esto es, una aproximación de un problema por otro problema lineal.
- ¿Por qué ponemos un *or* (||) en lugar de un *and* (&&) en las condiciones de Tolerancia del Residuo y Tolerancia en la Abscisa? Es decir,`if ydif < nl.tol || Fres < nl.tol`. Pues porque si la función es muy muy muy *vaso* entonces converge rápido en la ordenada pero en la abscisa quizá cuando converja el residuo en la ordenada ya sea del orden del épsilon de la máquina.
- El método de Newton para ecs. dif., por contra a iteración funcional, converge muy rápidamente, especialmente con un iterante inicial adecuado. Iteración funcional, sin embargo, perfectamente puede dar lugar a falsas convergencias: converge *a paso de tortuga*.
- **benchmark**: comparativa de rendimiento; básicamente correr un problema resuelto y tabulado con nuestro programa para ver si *tira como debe*.
- Tiene tela que la primera vez en la vida que derivo un operador que incluye operaciones de derivadas (G(y)=y''-u(x)-v(x)y^m-w(x)y') sea en esta asignatura. Bastante peculiar e incomprensible el proceso, de hecho.
- Hay problemas donde la información que se da en la ecuación diferencial es la condición final, no siempre debe ser necesariamente la condición inicial. El hecho es dar tanta información en la variable i-ésima como grados tiene la derivada de dicha variable (i.e. y'' => 2 cond. de contorno).
- La primera vez que tratamos de resolver un problema evolutivo usamos el *método de Euler implícito* para la variable t y *diferencias finitas* para la variable x.
- Para las derivadas primera y segunda hay distintas aproximaciones: podemos hacerlo en i+1 e i, en i-1 e i (de primer orden, lo primero que se ve) o en i-1, i e i+1 (esto son aproximaciones de segundo orden: i-1 e i+1 para la derivada).
- Implementar diferencias finitas hace posible escribir el problema como una ecuación en diferencias (i.e. una ecuación que involucra y_i-1, y_i, y_i+1,, etc.) cuya resolución viene de resolver un sistema matricial (pues al final tenemos un conjunto de ecuaciones lineales).
- Muy interesante este
- Testear código vale dinero. Por eso hay que usarlo lo más posible antes de cambiarlo.
- 
